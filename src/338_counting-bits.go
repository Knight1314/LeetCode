package src

/*
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]
进阶:

给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
要求算法的空间复杂度为O(n)。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/counting-bits
*/
func countBits(num int) []int {
	dp := make([]int, num+1)
	dp[0] = 0
	x := 0
	last2m := 0
	for i := 1; i <= num; i++ {
		if i>>x == 1 {
			dp[i] = 1
			last2m = i
			x++
		} else {
			dp[i] = dp[i-last2m] + dp[last2m]
		}
	}
	return dp
}

/*
1. 程序思维:
0 0  => 0
1 1  => 1
2 10 => 1
4 100=> 2

所有2的幂次方都是只有1个数
而其余数等于2的幂次方的数加上其余数的1，如7 = 4 + 3 => 4中的1的个数 + 3中的1的个数 => 1000 + 11 => 3

2. 取巧思维:
对于偶数而言：010+010 => 100 可知，如果任意一个数乘2，它的1的个数是不会变的，两个0变成0 两个1进位1，但是1的个数不变
对于奇数而言：010+011 => 101 可知一个奇数由一个偶数和一个奇数相加而得，可以转化为一个偶数+1 （010+010+1） 其实就相当于比偶数多一个1 可真真的完美

*/
